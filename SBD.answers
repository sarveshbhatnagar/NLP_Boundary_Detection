# A brief description of your own three additional features

I tried playing with more than 3 features 
1. get_avg_len(self, index, window=4)
2. get_average_len(self, index):
3. actual_len(self, index):
4. gt_x(self,index) (got deleted but I tried this too...)
5. lt_prev(self, index, val=2, o=0):
6. is_abbr(self, index)
The description for each except 4 is available in code.

A little detailed description for my choice of features (1,5 and 6) is below:
1: It returns average length of words using words at left and right of "."
5: lt_prev basically returns weather the word to the offset o is less than or equal to 
    val. It basically returns a bool. I used 2 variants.
6: is_abbr checks weather the word before "." is an abbrevation from a list of abbrevations
    or not. 


# How complete your program is

My program is complete. Following is my reasoning about choice of features and why I chose them.

At first I tried more numerical features, e.g. (1,2,3,4) but it gave very poor results
it actually decreased the accuracy... I then tried different length combinations and feature
combinations. After that I figured, an expert system would be more better as this struck me that
the abbrevation is something that I need to target. as something that is an abbrevation is probably
NEOS! I then tried to find some abbrevations and use them to create a boolean feature. This also
conforms that expert systems might be a good way for some tasks as compared with random 
training...

I also have one more feature that might further increase the accuracy which is to
find if the word contains a "." in between but haven't tried yet as
I have already spent very long on this assignment and the code run takes too long even after parallelization and
because being stuck initially with low accuracy... Anyways, that feature is if the
word left to "." is of length 1... Many of the text that is of len 1 might be NEOS with higher
probability as its mostly used with names (S. Bhatnagar)! Anyways this hypothesis is yet to be looked at...

descriptions of functions can be found in the class (which is well documented)

As discussed, using numerical features were reducing the accuracy so I tried to tend towards
boolean features instead... I chose the following custom features (1, 5 and 6) which increased
my accuracy to about 98.8%.

P.S. to detect if its a EOS/NEOS I used regular expression "/.$" which is find period
at the end of the string...


# If your program is complete, the accuracy of your system on the test data using all eight
features 

98.90%

# If your program is complete, the accuracy of your system on the test data using only the five
core features from the class.

94.06%

# If your program is complete, the accuracy of your system on the test data using only your
own three additional features.

89.83%

P.S.
Also made a Makefile for automation, added additional arguments -o & -c for custom run
(i.e. if -o is passed, it will set original flag to false which means only custom features will be used)
Used parallelization to improve speed by a bit.